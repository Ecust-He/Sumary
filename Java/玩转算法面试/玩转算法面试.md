[TOC]



## 时间复杂度

### 时间复杂度基础

#### 1、究竟什么是大O

```
	n表示数据规模
	O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比
```



#### 2、对数据规模有个概念(时间复杂度O(n))

```java
public static void main(String[] args) {

    // 数据规模每次增大10倍进行测试
    // 有兴趣的同学也可以试验一下数据规模每次增大2倍哦:)
    for( int x = 1 ; x <= 9 ; x ++ ){

        int n = (int)Math.pow(10, x);

        long startTime = System.currentTimeMillis();

        long sum = 0;
        for( int i = 0 ; i < n ; i ++ )
            sum += i;

        long endTime = System.currentTimeMillis();

        System.out.println("sum = " + sum);
        System.out.println("10^" + x + " : " + (endTime - startTime) + " ms");
        System.out.println("");
    }
}
```

### 简单的时间复杂度分析

```java
public class Main {

    // O(1)
    private static void swap(Object[] arr, int i, int j){

        if(i < 0 || i >= arr.length)
            throw new IllegalArgumentException("i is out of bound.");

        if(j < 0 || j >= arr.length)
            throw new IllegalArgumentException("j is out of bound.");

        Object temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // O(n)
    private static int sum(int n){

        if(n < 0)
            throw new IllegalArgumentException("n should be greater or equal to zero.");

        int ret = 0;
        for(int i = 0 ; i <= n ; i ++)
            ret += i;
        return ret;
    }

    private static void reverse(Object[] arr){

        int n = arr.length;
        for(int i = 0 ; i < n / 2 ; i ++ )
            swap(arr, i, n - 1 - i);
    }

    // O(n^2) Time Complexity
    private static void selectionSort(Comparable[] arr, int n){

        for(int i = 0 ; i < n ; i ++){
            int minIndex = i;
            for(int j = i + 1 ; j < n ; j ++)
                if(arr[j].compareTo(arr[minIndex]) < 0)
                    minIndex = j;

            swap(arr, i, minIndex);
        }
    }

    // O(n) Time Complexity
    private static void printInformation(int n){

        for( int i = 1 ; i <= n ; i ++ )
            for( int j = 1 ; j <= 30 ; j ++ )
                System.out.println("Class " + i + " - " + "No. " + j);
    }

    // O(logn) Time Complexity
    private static int binarySearch(Comparable[] arr, int n, int target){

        int l = 0, r = n-1;
        while( l <= r ){
            int mid = l + (r-l)/2;
            if(arr[mid].compareTo(target) == 0) return mid;
            if(arr[mid].compareTo(target) > 0) r = mid - 1;
            else l = mid + 1;
        }
        return -1;
    }

    private static String intToString(int num){

        StringBuilder s = new StringBuilder("");
        String sign = "+";
        if(num < 0){
            num = -num;
            sign = "-";
        }

        while(num != 0){
            s.append(Character.getNumericValue('0') + num % 10);
            num /= 10;
        }

        if(s.length() == 0)
            s.append('0');

        s.reverse();
        if(sign == "-")
            return sign + s.toString();
        else
            return s.toString();
    }


    // O(nlogn)
    private static void hello(int n){

        for( int sz = 1 ; sz < n ; sz += sz )
            for( int i = 1 ; i < n ; i ++ )
                System.out.println("Hello, Algorithm!");
    }


    // O(sqrt(n)) Time Complexity
    private static boolean isPrime(int num){

        for(int x = 2 ; x*x <= num ; x ++)
            if( num % x == 0 )
                return false;
        return true;
    }

    private static boolean isPrime2(int num){

        if( num <= 1 ) return false;
        if( num == 2 ) return true;
        if( num % 2 == 0 ) return false;

        for(int x = 3 ; x * x <= num ; x += 2)
            if( num%x == 0 )
                return false;

        return true;
    }

    public static void main(String[] args) {

        System.out.println(intToString(123));
        System.out.println(intToString(0));
        System.out.println(intToString(-123));

        System.out.println();

        if(isPrime2(137)) System.out.println("137 is a prime.");
        else System.out.println("137 is not a prime.");

        if(isPrime2(121)) System.out.println("121 is a prime.");
        else System.out.println("121 is not a prime.");
    }
}
```

### 试验自己算法时间复杂度

```java
public class Main {

    // binarySearch
    private static int binarySearch(Comparable[] arr, int l, int r, int target){

        if(l > r)
            return -1;

        int mid = l + (r - l) / 2;
        if(arr[mid].compareTo(target) == 0)
            return mid;
        else if(arr[mid].compareTo(target) > 0)
            return binarySearch(arr, l, mid - 1, target);
        else
            return binarySearch(arr, mid + 1, r, target);

    }

    // sum
    private static int sum(int n){

        assert n >= 0;

        if(n == 0)
            return 0;
        return n + sum(n - 1);
    }

    // pow2
    private static double pow(double x, int n){
        assert n >= 0;

        if(n == 0)
            return 1.0;

        double t = pow(x, n / 2);
        if(n % 2 == 1)
            return x * t * t;

        return t * t;
    }
}
```

### 递归算法时间复杂度分析

```java
public class Main {

    // binarySearch
    private static int binarySearch(Comparable[] arr, int l, int r, int target){

        if(l > r)
            return -1;

        int mid = l + (r - l) / 2;
        if(arr[mid].compareTo(target) == 0)
            return mid;
        else if(arr[mid].compareTo(target) > 0)
            return binarySearch(arr, l, mid - 1, target);
        else
            return binarySearch(arr, mid + 1, r, target);

    }

    // sum
    private static int sum(int n){

        assert n >= 0;

        if(n == 0)
            return 0;
        return n + sum(n - 1);
    }

    // pow2
    private static double pow(double x, int n){

        assert n >= 0;

        if(n == 0)
            return 1.0;

        double t = pow(x, n / 2);
        if(n % 2 == 1)
            return x * t * t;

        return t * t;
    }
}
```

### 均摊时间复杂度分析

```java
public class MyVector<Item> {

    private Item[] data;
    private int size;       // 存储数组中的元素个数
    private int capacity;   // 存储数组中可以容纳的最大的元素个数

    public MyVector(){
        data = (Item[])new Object[100];
        size = 0;
        capacity = 100;
    }

    // 平均复杂度为 O(1)
    public void push_back(Item e){

        if(size == capacity)
            resize(2 * capacity);

        data[size++] = e;
    }

    // 平均复杂度为 O(1)
    public Item pop_back(){

        if(size <= 0)
            throw new IllegalArgumentException("can not pop back for empty vector.");

        Item ret = data[size-1];
        size --;

        // 在size达到静态数组最大容量的1/4时才进行resize
        // resize的容量是当前最大容量的1/2
        // 防止复杂度的震荡
        if(size == capacity / 4)
            resize(capacity / 2);

        return ret;
    }

    // 复杂度为 O(n)
    private void resize(int newCapacity){

        assert newCapacity >= size;
        Item[] newData = (Item[])new Object[newCapacity];
        for(int i = 0 ; i < size ; i ++)
            newData[i] = data[i];

        data = newData;
        capacity = newCapacity;
    }

    // 注意：Java语言由于JVM内部机制的因素，测量的性能时间有可能是跳跃不稳定的。
    public static void main(String[] args) {

        for( int i = 10 ; i <= 26 ; i ++ ){

            int n = (int)Math.pow(2,i);

            long startTime = System.currentTimeMillis();
            MyVector<Integer> vec = new MyVector<Integer>();
            for(int num = 0 ; num < n ; num ++){
                vec.push_back(num);
            }
            for(int num = 0 ; num < n ; num ++){
                vec.pop_back();
            }
            long endTime = System.currentTimeMillis();

            System.out.print(2 * n + " operations: \t");
            System.out.println((endTime - startTime) + " ms");
        }
    }
}
```

## 数组

### 二分查找法

#### 方法一

```java
public class BinarySearch {

    private BinarySearch(){}

    public static int binarySearch(Comparable[] arr, int n, Comparable target){

        int l = 0, r = n - 1; // 在[l...r]的范围里寻找target
        while(l <= r){    // 当 l == r时,区间[l...r]依然是有效的
            int mid = l + (r - l) / 2;
            if(arr[mid].compareTo(target) == 0) return mid;
            if(target.compareTo(arr[mid]) > 0)
                l = mid + 1;  // target在[mid+1...r]中; [l...mid]一定没有target
            else    // target < arr[mid]
                r = mid - 1;  // target在[l...mid-1]中; [mid...r]一定没有target
        }

        return -1;
    }
}
```

#### 方法二

```java
public class BinarySearch {

    private BinarySearch(){}

    public static int binarySearch(Comparable[] arr, int n, Comparable target){

        int l = 0, r = n; // 在[l...r)的范围里寻找target
        while(l < r){    // 当 l == r 时, 区间[l...r)是一个无效区间
            int mid = l + (r - l) / 2;
            if(arr[mid].compareTo(target) == 0) return mid;
            if(target.compareTo(arr[mid]) > 0)
                l = mid + 1;  // target在[mid+1...r)中; [l...mid]一定没有target
            else    // target < arr[mid]
                r = mid;  // target在[l...mid)中; [mid...r)一定没有target
        }

        return -1;
    }

    public static void main(String[] args) {

        int n = (int)Math.pow(10, 7);
        Integer data[] = Util.generateOrderedArray(n);

        long startTime = System.currentTimeMillis();
        for(int i = 0 ; i < n ; i ++)
            if(i != binarySearch(data, n, i))
                throw new IllegalStateException("find i failed!");
        long endTime = System.currentTimeMillis();

        System.out.println("Binary Search 2 test complete.");
        System.out.println("Time cost: " + (endTime - startTime) + " ms");
    }
}
```

### Move Zeros(LeetCode)

#### 方法一

```java
// 283. Move Zeroes
// https://leetcode.com/problems/move-zeroes/
class Solution {
    // 时间复杂度: O(n)
	// 空间复杂度: O(n)
    public void moveZeroes(int[] nums) {

        ArrayList<Integer> nonZeroElements = new ArrayList<Integer>();

        // 将vec中所有非0元素放入nonZeroElements中
        for(int i = 0 ; i < nums.length ; i ++)
            if(nums[i] != 0)
                nonZeroElements.add(nums[i]);

        // 将nonZeroElements中的所有元素依次放入到nums开始的位置
        for(int i = 0 ; i < nonZeroElements.size() ; i ++)
            nums[i] = nonZeroElements.get(i);

        // 将nums剩余的位置放置为0
        for(int i = nonZeroElements.size() ; i < nums.length ; i ++)
            nums[i] = 0;
    }

    public static void main(String args[]){

        int[] arr = {0, 1, 0, 3, 12};

        (new Solution()).moveZeroes(arr);

        for(int i = 0 ; i < arr.length ; i ++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }
}
```

#### 方法二

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public void moveZeroes(int[] nums) {

    int k = 0; // nums中, [0...k)的元素均为非0元素

    // 遍历到第i个元素后,保证[0...i]中所有非0元素
    // 都按照顺序排列在[0...k)中
    for(int i = 0 ; i < nums.length ; i ++)
        if( nums[i] != 0 )
            nums[k++] = nums[i];

    // 将nums剩余的位置放置为0
    for(int i = k ; i < nums.length ; i ++)
        nums[i] = 0;
}
```

#### 方法三

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public void moveZeroes(int[] nums) {

    int k = 0; // nums中, [0...k)的元素均为非0元素

    // 遍历到第i个元素后,保证[0...i]中所有非0元素
    // 都按照顺序排列在[0...k)中
    // 同时, [k...i] 为 0
    for(int i = 0 ; i < nums.length ; i ++)
        if(nums[i] != 0)
            swap(nums, k++, i);
}

private void swap(int[] nums, int i, int j){
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

#### 方法四

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public void moveZeroes(int[] nums) {

    int k = 0; // nums中, [0...k)的元素均为非0元素

    // 遍历到第i个元素后,保证[0...i]中所有非0元素
    // 都按照顺序排列在[0...k)中
    // 同时, [k...i] 为 0
    for(int i = 0 ; i < nums.length ; i ++)
        if(nums[i] != 0)
            if(k != i)
                swap(nums, k++, i);
            else
                k ++;
}

private void swap(int[] nums, int i, int j){
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

#### 方法五

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
// 对整个数组只遍历一遍
public void moveZeroes(int[] nums) {
    int nonZeroIndex = -1;// nums中, [0...nonZeroIndex]的元素均为非0元素
    for (int i = 0; i < nums.length; i++) {
        if(nums[i] != 0) {
            nums[++nonZeroIndex] = nums[i];
            if(nonZeroIndex < i) {
                nums[i] = 0;
            }
        }
    }
}
```
### Sort Colors(LeetCode)

#### 方法一

```java
// 75. Sort Colors
// https://leetcode.com/problems/sort-colors/description/
// 计数排序的思路
// 对整个数组遍历了两遍
// 时间复杂度: O(n)
// 空间复杂度: O(k), k为元素的取值范围
public class Solution1 {

    public void sortColors(int[] nums) {

        int[] count = {0, 0, 0};    // 存放0, 1, 2三个元素的频率
        for(int i = 0 ; i < nums.length ; i ++){
            assert nums[i] >= 0 && nums[i] <= 2;
            count[nums[i]] ++;
        }

        int index = 0;
        for(int i = 0 ; i < count[0] ; i ++)
            nums[index++] = 0;
        for(int i = 0 ; i < count[1] ; i ++)
            nums[index++] = 1;
        for(int i = 0 ; i < count[2] ; i ++)
            nums[index++] = 2;
        // 小练习: 自学编写计数排序算法
    }

    public static void printArr(int[] nums){
        for(int num: nums)
            System.out.print(num + " ");
        System.out.println();
    }

    public static void main(String[] args) {
        int[] nums = {2, 2, 2, 1, 1, 0};
        (new Solution1()).sortColors(nums);
        printArr(nums);
    }
}
```

#### 方法二

```
// 三路快速排序的思想
// 对整个数组只遍历了一遍
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public void sortColors(int[] nums) {

    int zero = -1;          // [0...zero] == 0
    int two = nums.length;  // [two...n-1] == 2
    for(int i = 0 ; i < two ; ){
        if(nums[i] == 1)
            i ++;
        else if (nums[i] == 2)
            swap(nums, i, --two);
        else{ // nums[i] == 0
            assert nums[i] == 0;
            swap(nums, ++zero, i++);
        }
    }
}

private void swap(int[] nums, int i, int j){
    int t = nums[i];
    nums[i]= nums[j];
    nums[j] = t;
}
```

### Two Sum II(LeetCode)

#### 方法一

```java
// 167. Two Sum II - Input array is sorted
// https://leetcode.com/problems/two-sum-ii-input-array-is-sorted
// 暴力枚举法
// 时间复杂度: O(n^2)
// 空间复杂度: O(1)
public int[] twoSum(int[] numbers, int target) {

    if(numbers.length < 2 /*|| !isSorted(numbers)*/)
        throw new IllegalArgumentException("Illegal argument numbers");

    for(int i = 0 ; i < numbers.length ; i ++)
        for(int j = i+1 ; j < numbers.length ; j ++)
            if(numbers[i] + numbers[j] == target){
                int[] res = {i+1, j+1};
                return res;
            }

    throw new IllegalStateException("The input has no solution");
}
```

#### 方法二

```java
// 二分搜索法
// 时间复杂度: O(nlogn)
// 空间复杂度: O(1)
public int[] twoSum(int[] numbers, int target) {

    if(numbers.length < 2 /*|| !isSorted(numbers)*/)
        throw new IllegalArgumentException("Illegal argument numbers");

    for(int i = 0 ; i < numbers.length - 1 ; i ++){
        int j = binarySearch(numbers, i+1, numbers.length-1, target - numbers[i]);
        if(j != -1){
            int[] res = {i+1, j+1};
            return res;
        }
    }

    throw new IllegalStateException("The input has no solution");
}

private int binarySearch(int[] nums, int l, int r, int target){

    if(l < 0 || l > nums.length)
        throw new IllegalArgumentException("l is out of bound");

    if(r < 0 || r > nums.length)
        throw new IllegalArgumentException("r is out of bound");

    while(l <= r){
        int mid = l + (r - l)/2;
        if(nums[mid] == target)
            return mid;
        if(target > nums[mid])
            l = mid + 1;
        else
            r = mid - 1;
    }
    return -1;
}
```

#### 方法三

```java
// 对撞指针
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public int[] twoSum(int[] numbers, int target) {

    if(numbers.length < 2 /*|| !isSorted(numbers)*/)
        throw new IllegalArgumentException("Illegal argument numbers");

    int l = 0, r = numbers.length - 1;
    while(l < r){

        if(numbers[l] + numbers[r] == target){
            int[] res = {l+1, r+1};
            return res;
        }
        else if(numbers[l] + numbers[r] < target)
            l ++;
        else // numbers[l] + numbers[r] > target
            r --;
    }
    throw new IllegalStateException("The input has no solution");
}
```

### Minimum Size Subarray Sum(LeetCode)

#### 方法一

```java
// 209. Minimum Size Subarray Sum
// https://leetcode.com/problems/minimum-size-subarray-sum
// 暴力解法
// 该方法在 Leetcode 中会超时！
// 时间复杂度: O(n^3)
// 空间复杂度: O(1)
public int minSubArrayLen(int s, int[] nums) {

    if(s <= 0 || nums == null)
        throw new IllegalArgumentException("Illigal Arguments");

    int res = nums.length + 1;
    for(int l = 0 ; l < nums.length ; l ++)
        for(int r = l ; r < nums.length ; r ++){
            int sum = 0;
            for(int i = l ; i <= r ; i ++)
                sum += nums[i];
            if(sum >= s)
                res = Math.min(res, r - l + 1);
        }

    if(res == nums.length + 1)
        return 0;

    return res;
}
```

#### 方法 二

```java
// 优化暴力解
// 时间复杂度: O(n^2)
// 空间复杂度: O(n)
public int minSubArrayLen(int s, int[] nums) {

    if(s <= 0 || nums == null)
        throw new IllegalArgumentException("Illigal Arguments");

    // sums[i]存放nums[0...i-1]的和
    int[] sums = new int[nums.length + 1];
    sums[0] = 0;
    for(int i = 1 ; i <= nums.length ; i ++)
        sums[i] = sums[i-1] + nums[i-1];

    int res = nums.length + 1;
    for(int l = 0 ; l < nums.length ; l ++)
        for(int r = l ; r < nums.length ; r ++){
            // 使用sums[r+1] - sums[l] 快速获得nums[l...r]的和
            if(sums[r+1] - sums[l] >= s)
                res = Math.min(res, r - l + 1);
        }

    if(res == nums.length + 1)
        return 0;

    return res;
}
```

#### 方法三

```java
// 滑动窗口的思路
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public int minSubArrayLen(int s, int[] nums) {

    if(s <= 0 || nums == null)
        throw new IllegalArgumentException("Illigal Arguments");

    int l = 0 , r = -1; // nums[l...r]为我们的滑动窗口
    int sum = 0;
    int res = nums.length + 1;

    while(l < nums.length){   // 窗口的左边界在数组范围内,则循环继续

        if(r + 1 < nums.length && sum < s)
            sum += nums[++r];
        else // r已经到头 或者 sum >= s
            sum -= nums[l++];

        if(sum >= s)
            res = Math.min(res, r - l + 1);
    }

    if(res == nums.length + 1)
        return 0;
    return res;
}
```

#### 方法四

```java
// 另外一个滑动窗口的实现, 仅供参考
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public int minSubArrayLen(int s, int[] nums) {

    if(s <= 0 || nums == null)
        throw new IllegalArgumentException("Illigal Arguments");

    int l = 0 , r = -1; // [l...r]为我们的窗口
    int sum = 0;
    int res = nums.length + 1;

    while(r + 1 < nums.length){   // 窗口的右边界无法继续扩展了, 则循环继续

        while(r + 1 < nums.length && sum < s)
            sum += nums[++r];

        if(sum >= s)
            res = Math.min(res, r - l + 1);

        while(l < nums.length && sum >= s){
            sum -= nums[l++];
            if(sum >= s)
                res = Math.min(res, r - l + 1);
        }
    }

    if(res == nums.length + 1)
        return 0;
    return res;
}
```

### Longest Substring Without Repeating Characters(LeetCode)

#### 方法一

```java
// 3. Longest Substring Without Repeating Characters
// https://leetcode.com/problems/longest-substring-without-repeating-characters
// 滑动窗口
// 时间复杂度: O(len(s))
// 空间复杂度: O(len(charset))
public int lengthOfLongestSubstring(String s) {

    int[] freq = new int[256];

    int l = 0, r = -1; //滑动窗口为s[l...r]
    int res = 0;

    // 整个循环从 l == 0; r == -1 这个空窗口开始
    // 到l == s.size(); r == s.size()-1 这个空窗口截止
    // 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值
    while(l < s.length()){

        if(r + 1 < s.length() && freq[s.charAt(r+1)] == 0)
            freq[s.charAt(++r)] ++;
        else    //r已经到头 || freq[s[r+1]] == 1
            freq[s.charAt(l++)] --;

        res = Math.max(res, r-l+1);
    }
    return res;
}
```

#### 方法 二

```java
// 滑动窗口
// 时间复杂度: O(len(s))
// 空间复杂度: O(len(charset))
public int lengthOfLongestSubstring(String s) {

    int[] freq = new int[256];

    int l = 0, r = -1; //滑动窗口为s[l...r]
    int res = 0;

    // 在这里, 循环中止的条件可以是 r + 1 < s.length(), 想想看为什么?
    while( r + 1 < s.length() ){

        if( r + 1 < s.length() && freq[s.charAt(r+1)] == 0 )
            freq[s.charAt(++r)] ++;
        else    //freq[s[r+1]] == 1
            freq[s.charAt(l++)] --;

        res = Math.max(res, r-l+1);
    }

    return res;
}
```

#### 方法三

```java
// 滑动窗口的另一个实现, 仅做参考
// 时间复杂度: O(len(s))
// 空间复杂度: O(len(charset))
public int lengthOfLongestSubstring(String s) {

    int[] freq = new int[256];

    int l = 0, r = -1; //滑动窗口为s[l...r]
    int res = 0;

    while(r + 1 < s.length()){

        while(r + 1 < s.length() && freq[s.charAt(r+1)] == 0)
            freq[s.charAt(++r)] ++;

        res = Math.max(res, r - l + 1);

        if(r + 1 < s.length()){
            freq[s.charAt(++r)] ++;
            assert(freq[s.charAt(r)] == 2);
            while(l <= r && freq[s.charAt(r)] == 2)
                freq[s.charAt(l++)] --;
        }
    }
    return res;
}
```

#### 方法四

```java
// 时间复杂度: O(len(s)*len(charset))
// 空间复杂度: O(1)
public int lengthOfLongestSubstring(String s) {

    int l = 0, r = 0; //滑动窗口为s[l...r]
    int res = 0;

    while(r < s.length()){

        int index = isDuplicateChar(s, l, r);

        // 如果s[r]之前出现过
        // l可以直接跳到s[r+1]之前出现的位置 + 1的地方
        if(index != -1)
            l = index + 1;

        res = Math.max(res, r-l+1);
        r ++;
    }

    return res;
}

// 查看s[l...r-1]之间是否存在s[r]
// 若存在,返回相应的索引, 否则返回-1
private int isDuplicateChar(String s, int l, int r){
    for(int i = l ; i < r ; i ++)
        if(s.charAt(i) == s.charAt(r))
            return i;
    return -1;
}
```

#### 方法五

```java
// 时间复杂度: O(len(s))
// 空间复杂度: O(len(charset))
public int lengthOfLongestSubstring(String s) {

    int[] last = new int[256];
    Arrays.fill(last, -1);

    int l = 0, r = -1; //滑动窗口为s[l...r]
    int res = 0;
    while(r + 1 < s.length()){

        r ++;
        if(last[s.charAt(r)] != -1)
            l = Math.max(l, last[s.charAt(r)] + 1);

        res = Math.max(res, r - l + 1);
        last[s.charAt(r)] = r;
    }

    return res;
}
```

## Hash表

### Intersection of Two Arrays(LeetCode)

#### 方法一

```java
// 349. Intersection of Two Arrays
// https://leetcode.com/problems/intersection-of-two-arrays
// 时间复杂度: O(nlogn)
// 空间复杂度: O(n)
public int[] intersection(int[] nums1, int[] nums2) {

    TreeSet<Integer> record = new TreeSet<Integer>();
    for(int num: nums1)
        record.add(num);

    TreeSet<Integer> resultSet = new TreeSet<Integer>();
    for(int num: nums2)
        if(record.contains(num))
            resultSet.add(num);

    int[] res = new int[resultSet.size()];
    int index = 0;
    for(Integer num: resultSet)
        res[index++] = num;

    return res;
}
```

#### 方法二

```java
// 时间复杂度: O(len(nums1)+len(nums2))
// 空间复杂度: O(len(nums1))
public int[] intersection(int[] nums1, int[] nums2) {

    HashSet<Integer> record = new HashSet<Integer>();
    for(int num: nums1)
        record.add(num);

    HashSet<Integer> resultSet = new HashSet<Integer>();
    for(int num: nums2)
        if(record.contains(num))
            resultSet.add(num);

    int[] res = new int[resultSet.size()];
    int index = 0;
    for(Integer num: resultSet)
        res[index++] = num;

    return res;
}
```

### Intersection of Two Arrays II(LeetCode)

#### 方法一

```java
// 350. Intersection of Two Arrays II
// https://leetcode.com/problems/intersection-of-two-arrays-ii
// 时间复杂度: O(nlogn)
// 空间复杂度: O(n)
public int[] intersect(int[] nums1, int[] nums2) {

    TreeMap<Integer, Integer> record = new TreeMap<Integer, Integer>();
    for(int num: nums1)
        if(!record.containsKey(num))
            record.put(num, 1);
        else
            record.put(num, record.get(num) + 1);

    ArrayList<Integer> result = new ArrayList<Integer>();
    for(int num: nums2)
        if(record.containsKey(num) && record.get(num) > 0){
            result.add(num);
            record.put(num, record.get(num) - 1);
        }

    int[] ret = new int[result.size()];
    int index = 0;
    for(Integer num: result)
        ret[index++] = num;

    return ret;
}
```

#### 方法二

```java
// 时间复杂度: O(len(nums1)+len(nums2))
// 空间复杂度: O(len(nums1))
public int[] intersect(int[] nums1, int[] nums2) {

    HashMap<Integer, Integer> record = new HashMap<Integer, Integer>();
    for(int num: nums1)
        if(!record.containsKey(num))
            record.put(num, 1);
        else
            record.put(num, record.get(num) + 1);

    ArrayList<Integer> result = new ArrayList<Integer>();
    for(int num: nums2)
        if(record.containsKey(num) && record.get(num) > 0){
            result.add(num);
            record.put(num, record.get(num) - 1);
        }

    int[] ret = new int[result.size()];
    int index = 0;
    for(Integer num: result)
        ret[index++] = num;

    return ret;
}
```

### Two Sum（LeetCode）

```java
// 1. Two Sum
// https://leetcode.com/problems/two-sum
// 时间复杂度：O(n)
// 空间复杂度：O(n)
public int[] twoSum(int[] nums, int target) {

    HashMap<Integer, Integer> record = new HashMap<Integer, Integer>();
    for(int i = 0 ; i < nums.length; i ++){

        int complement = target - nums[i];
        if(record.containsKey(complement)){
            int[] res = {i, record.get(complement)};
            return res;
        }

        record.put(nums[i], i);
    }

    throw new IllegalStateException("the input has no solution");
}
```

### 4Sum II（LeetCode）

```java
// 454. 4Sum II
// https://leetcode.com/problems/4sum-ii/description/
// 时间复杂度: O(n^2)
// 空间复杂度: O(n^2)
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {

        if(A == null || B == null || C == null || D == null)
            throw new IllegalArgumentException("Illegal argument");

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < C.length ; i ++)
            for(int j = 0 ; j < D.length ; j ++){
                int sum = C[i] + D[j];
                if(map.containsKey(sum))
                    map.put(sum, map.get(sum) + 1);
                else
                    map.put(sum, 1);
            }

        int res = 0;
        for(int i = 0 ; i < A.length ; i ++)
            for(int j = 0 ; j < B.length ; j ++)
                if(map.containsKey(-A[i]-B[j]))
                    res += map.get(-A[i]-B[j]);

        return res;
    }
```

### Number of Boomerangs（LeetCode）

```java
// 447. Number of Boomerangs
// https://leetcode.com/problems/number-of-boomerangs
// 时间复杂度: O(n^2)
// 空间复杂度: O(n)
public int numberOfBoomerangs(int[][] points) {

    int res = 0;
    for( int i = 0 ; i < points.length ; i ++ ){

        // record中存储 点i 到所有其他点的距离出现的频次
        HashMap<Integer, Integer> record = new HashMap<Integer, Integer>();
        for(int j = 0 ; j < points.length ; j ++)
            if(j != i){
                // 计算距离时不进行开根运算, 以保证精度
                int dis = dis(points[i], points[j]);
                if(record.containsKey(dis))
                    record.put(dis, record.get(dis) + 1);
                else
                    record.put(dis, 1);
        }

        for(Integer dis: record.keySet())
            res += record.get(dis) * (record.get(dis) - 1);
    }

    return res;
}

private int dis(int[] pa, int pb[]){
    return (pa[0] - pb[0]) * (pa[0] - pb[0]) +
           (pa[1] - pb[1]) * (pa[1] - pb[1]);
}
```

### Contains Duplicate II（LeetCode）

```java
// 219. Contains Duplicate II
// https://leetcode.com/problems/contains-duplicate-ii
// 时间复杂度: O(n)
// 空间复杂度: O(k)
public boolean containsNearbyDuplicate(int[] nums, int k) {

    if(nums == null || nums.length <= 1)
        return false;

    if(k <= 0)
        return false;

    HashSet<Integer> record = new HashSet<Integer>();
    for(int i = 0 ; i < nums.length; i ++){
        if(record.contains(nums[i]))
            return true;

        record.add(nums[i]);
        if(record.size() == k + 1)
            record.remove(nums[i-k]);
    }

    return false;
}
```

### Contains Duplicate III（LeetCode）

```java
// 220. Contains Duplicate III
// https://leetcode.com/problems/contains-duplicate-iii
// 时间复杂度: O(nlogk)
// 空间复杂度: O(k)
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {

    // 这个问题的测试数据在使用int进行加减运算时会溢出
    // 所以使用long long
    TreeSet<Long> record = new TreeSet<Long>();
    for(int i = 0 ; i < nums.length ; i ++){

        if(record.ceiling((long)nums[i] - (long)t) != null &&
                record.ceiling((long)nums[i] - (long)t) <= (long)nums[i] + (long)t)
        return true;

        record.add((long)nums[i]);

        if(record.size() == k + 1)
            record.remove((long)nums[i-k]);
    }

    return false;
}
```
## 链表

### Reverse Linked List(LeetCode)

#### 方法一（迭代）

```java
// 206. Reverse Linked List
// https://leetcode.com/problems/reverse-linked-list
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public ListNode reverseList(ListNode head) {

    ListNode pre = null;
    ListNode cur = head;
    while(cur != null){
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

#### 方法二（递归）

```java
// 时间复杂度: O(n)
// 空间复杂度: O(n) 注意：递归是占用空间的，占用空间的大小和递归深度成正比
public ListNode reverseList(ListNode head) {

    // 递归终止条件
    if(head == null|| head.next == null)
        return head;

    ListNode rhead = reverseList(head.next);

    // head->next此刻指向head后面的链表的尾节点
    // head->next->next = head把head节点放在了尾部
    head.next.next = head;
    head.next = null;

    return rhead;
}
```

### Remove Linked List Elements（LeetCode）

#### 方法一（不使用虚拟头结点）

```java
// 203. Remove Linked List Elements
// https://leetcode.com/problems/remove-linked-list-elements
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public ListNode removeElements(ListNode head, int val) {

    // 需要对头结点进行特殊处理
    while(head != null && head.val == val){
        ListNode node = head;
        head = head.next;
    }

    if(head == null)
        return head;

    ListNode cur = head;
    while(cur.next != null){
        if(cur.next.val == val){
            ListNode delNode = cur.next;
            cur.next = delNode.next;
        }
        else
            cur = cur.next;
    }

    return head;
}
```

#### 方法二（使用虚拟头结点）

```java
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public ListNode removeElements(ListNode head, int val) {

    // 创建虚拟头结点
    ListNode dummyHead = new ListNode(0);
    dummyHead.next = head;

    ListNode cur = dummyHead;
    while(cur.next != null){
        if(cur.next.val == val ){
            ListNode delNode = cur.next;
            cur.next = delNode.next;
        }
        else
            cur = cur.next;
    }

    return dummyHead.next;
}
```

### Swap Nodes in Pairs（LeetCode）

```java
// 24. Swap Nodes in Pairs
// https://leetcode.com/problems/swap-nodes-in-pairs
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public ListNode swapPairs(ListNode head) {

    ListNode dummyHead = new ListNode(0);
    dummyHead.next = head;

    ListNode p = dummyHead;
    while(p.next != null && p.next.next != null ){
        ListNode node1 = p.next;
        ListNode node2 = node1.next;
        ListNode next = node2.next;
        node2.next = node1;
        node1.next = next;
        p.next = node2;
        p = node1;
    }

    return dummyHead.next;
}
```

### Delete Node in a Linked List（LeetCode）

```java
// 237. Delete Node in a Linked List
// https://leetcode.com/problems/delete-node-in-a-linked-list
// 时间复杂度: O(1)
// 空间复杂度: O(1)
public void deleteNode(ListNode node) {

    // 注意: 这个方法对尾节点不适用。题目中要求了给定的node不是尾节点
    // 我们检查node.next, 如果为null则抛出异常, 确保了node不是尾节点
    if(node == null || node.next == null)
        throw new IllegalArgumentException("node should be valid and can not be the tail node.");

    node.val = node.next.val;
    node.next = node.next.next;
}
```

#### Remove Nth Node From End of List（LeetCode）

#### 方法一

```java
// 19. Remove Nth Node From End of List
// https://leetcode.com/problems/remove-nth-node-from-end-of-list
// 先记录链表总长度
// 需要对链表进行两次遍历
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public ListNode removeNthFromEnd(ListNode head, int n) {

    ListNode dummyHead = new ListNode(0);
    dummyHead.next = head;

    int length = 0;
    for(ListNode cur = dummyHead.next ; cur != null ; cur = cur.next)
        length ++;

    int k = length - n;
    assert k >= 0;
    ListNode cur = dummyHead;
    for(int i = 0 ; i < k ; i ++)
        cur = cur.next;

    cur.next = cur.next.next;

    return dummyHead.next;
}
```

#### 方法二

```java
// 使用双指针, 对链表只遍历了一遍
// 时间复杂度: O(n)
// 空间复杂度: O(1)
public ListNode removeNthFromEnd(ListNode head, int n) {

    ListNode dummyHead = new ListNode(0);
    dummyHead.next = head;

    ListNode p = dummyHead;
    ListNode q = dummyHead;
    for( int i = 0 ; i < n + 1 ; i ++ ){
        assert q != null;
        q = q.next;
    }

    while(q != null){
        p = p.next;
        q = q.next;
    }

    p.next = p.next.next;

    return dummyHead.next;
}
```
## 栈和队列

### Valid Parentheses(LeetCode)

```java
// 20. Valid Parentheses
// https://leetcode.com/problems/valid-parentheses
// 时间复杂度: O(n)
// 空间复杂度: O(n)
public boolean isValid(String s) {

    Stack<Character> stack = new Stack<Character>();
    for( int i = 0 ; i < s.length() ; i ++ )
        if( s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[')
            stack.push(s.charAt(i));
        else{

            if( stack.size() == 0 )
                return false;

            Character c = stack.pop();

            Character match;
            if( s.charAt(i) == ')' )
                match = '(';
            else if( s.charAt(i) == ']' )
                match = '[';
            else{
                assert s.charAt(i) == '}';
                match = '{';
            }

            if(c != match)
                return false;
        }

    if( stack.size() != 0 )
        return false;

    return true;
}
```

### Binary Tree Level Order Traversal（LeetCode）

```java
/// 102. Binary Tree Level Order Traversal
/// https://leetcode.com/problems/binary-tree-level-order-traversal
/// 二叉树的层序遍历
/// 时间复杂度: O(n), n为树的节点个数
/// 空间复杂度: O(n)
public List<List<Integer>> levelOrder(TreeNode root) {

    ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
    if(root == null)
        return res;

    // 我们使用LinkedList来做为我们的先入先出的队列
    LinkedList<Pair<TreeNode, Integer>> queue = new LinkedList<Pair<TreeNode, Integer>>();
    queue.addLast(new Pair<TreeNode, Integer>(root, 0));

    while(!queue.isEmpty()){

        Pair<TreeNode, Integer> front = queue.removeFirst();
        TreeNode node = front.getKey();
        int level = front.getValue();

        if(level == res.size())
            res.add(new ArrayList<Integer>());
        assert level < res.size();

        res.get(level).add(node.val);
        if(node.left != null)
            queue.addLast(new Pair<TreeNode, Integer>(node.left, level + 1));
        if(node.right != null)
            queue.addLast(new Pair<TreeNode, Integer>(node.right, level + 1));
    }

    return res;
}
```

###  Perfect Squares（LeetCode）

#### 方法一

```java
// 279. Perfect Squares
// https://leetcode.com/problems/perfect-squares
// 该方法会导致 Time Limit Exceeded 或者 Memory Limit Exceeded
// 时间复杂度: O(2^n)
// 空间复杂度: O(2^n)
public int numSquares(int n) {

    LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();
    queue.addLast(new Pair<Integer, Integer>(n, 0));

    while(!queue.isEmpty()){
        Pair<Integer, Integer> front = queue.removeFirst();
        int num = front.getKey();
        int step = front.getValue();

        if(num == 0)
            return step;

        for(int i = 1 ; num - i*i >= 0 ; i ++)
            queue.addLast(new Pair(num - i * i, step + 1));
    }

    throw new IllegalStateException("No Solution.");
}
```

#### 方法二

```java
// 使用visited数组,记录每一个入队元素
// 时间复杂度: O(n)
// 空间复杂度: O(n)
public int numSquares(int n) {

    LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();
    queue.addLast(new Pair<Integer, Integer>(n, 0));

    boolean[] visited = new boolean[n+1];
    visited[n] = true;

    while(!queue.isEmpty()){
        Pair<Integer, Integer> front = queue.removeFirst();
        int num = front.getKey();
        int step = front.getValue();

        if(num == 0)
            return step;

        for(int i = 1 ; num - i*i >= 0 ; i ++)
            if(!visited[num - i * i]){
                queue.addLast(new Pair(num - i * i, step + 1));
                visited[num - i * i] = true;
            }
    }

    throw new IllegalStateException("No Solution.");
}
```

#### 方法三

```java
// 进一步优化
// 时间复杂度: O(n)
// 空间复杂度: O(n)
public int numSquares(int n) {

    if(n == 0)
        return 0;

    LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();
    queue.addLast(new Pair<Integer, Integer>(n, 0));

    boolean[] visited = new boolean[n+1];
    visited[n] = true;

    while(!queue.isEmpty()){
        Pair<Integer, Integer> front = queue.removeFirst();
        int num = front.getKey();
        int step = front.getValue();

        if(num == 0)
            return step;

        for(int i = 1 ; num - i*i >= 0 ; i ++){
            int a = num - i*i;
            if(!visited[a]){
                if(a == 0) return step + 1;
                queue.addLast(new Pair(num - i * i, step + 1));
                visited[num - i * i] = true;
            }
        }
    }

    throw new IllegalStateException("No Solution.");
}
```
### Top K Frequent Elements（LeetCode）

```java
// 347. Top K Frequent Elements
// https://leetcode.com/problems/top-k-frequent-elements
// 时间复杂度: O(nlogk)
// 空间复杂度: O(n + k)
class Solution {

    private class PairComparator implements Comparator<Pair<Integer, Integer>>{

        @Override
        public int compare(Pair<Integer, Integer> p1, Pair<Integer, Integer> p2){
            if(p1.getKey() != p2.getKey())
                return p1.getKey() - p2.getKey();
            return p1.getValue() - p2.getValue();
        }
    }

    public List<Integer> topKFrequent(int[] nums, int k) {

        if(k <= 0)
            throw new IllegalArgumentException("k should be greater than 0");

        // 统计每个元素出现的频率
        HashMap<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < nums.length ; i ++)
            if(freq.containsKey(nums[i]))
                freq.put(nums[i], freq.get(nums[i]) + 1);
            else
                freq.put(nums[i], 1);

        if(k > freq.size())
            throw new IllegalArgumentException("k should be less than the number of unique numbers in nums");

        // 扫描freq,维护当前出现频率最高的k个元素
        // 在优先队列中,按照频率排序,所以数据对是 (频率,元素) 的形式
        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<Pair<Integer, Integer>>(new PairComparator());
        for(Integer num: freq.keySet()){
            int numFreq = freq.get(num);
            if(pq.size() == k){
                if(numFreq > pq.peek().getKey()){
                    pq.poll();
                    pq.add(new Pair(numFreq, num));
                }
            }
            else
                pq.add(new Pair(numFreq, num));
        }

        ArrayList<Integer> res = new ArrayList<Integer>();
        while(!pq.isEmpty())
            res.add(pq.poll().getValue());

        return res;
    }
}
```

###  Word Ladder（LeetCode）

#### 方法一

```java
//127. https://leetcode.com/problems/word-ladder
/// BFS
/// Time Complexity: O(n*n)
/// Space Complexity: O(n)
public class Solution {

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {

        int end = wordList.indexOf(endWord);
        if(end == -1)
            return 0;

        if(!wordList.contains(beginWord))
            wordList.add(beginWord);
        int begin = wordList.indexOf(beginWord);

        int n = wordList.size();
        boolean[][] g = new boolean[n][n];
        for(int i = 0 ; i < n ; i ++)
            for(int j = 0 ; j < i ; j ++)
                g[j][i] = g[i][j] = similar(wordList.get(i), wordList.get(j));

        // bfs
        LinkedList<Integer> q = new LinkedList<>();
        int[] step = new int[n];

        q.addLast(begin);
        step[begin] = 1;
        while(!q.isEmpty()){

            int cur = q.removeFirst();

            for(int i = 0 ; i < n ; i ++)
                if(step[i] == 0 && g[cur][i]){
                    if(i == end)
                        return step[cur] + 1;
                    step[i] = step[cur] + 1;
                    q.addLast(i);
                }
        }

        return 0;
    }

    private boolean similar(String word1, String word2){

        if(word1.length() != word2.length() || word1.equals(word2))
            throw new IllegalArgumentException();

        int diff = 0;
        for(int i = 0 ; i < word1.length() ; i ++)
            if(word1.charAt(i) != word2.charAt(i)){
                diff ++;
                if(diff > 1)
                    return false;
            }
        return true;
    }
```

#### 方法二

```java
/// BFS
/// Using set to store all the words and erase visited word eagerly.
/// Time Complexity: O(n*n)
/// Space Complexity: O(n)
public int ladderLength(String beginWord, String endWord, List<String> wordList) {

    HashSet<String> wordSet = new HashSet<>();
    for(String word: wordList)
        wordSet.add(word);

    // bfs
    LinkedList<Pair<String, Integer>> q = new LinkedList<>();
    q.addLast(new Pair<>(beginWord, 1));
    wordSet.remove(beginWord);

    HashSet<String> visited = new HashSet<>();

    while(!q.isEmpty()){

        String curWord = q.getFirst().getKey();
        int curStep = q.getFirst().getValue();
        q.removeFirst();

        visited.clear();
        for(String word: wordSet){
            if(similar(word, curWord)){
                if(word.equals(endWord))
                    return curStep + 1;
                q.addLast(new Pair<>(word, curStep + 1));
                visited.add(word);
            }
        }

        for(String word: visited)
            wordSet.remove(word);
    }

    return 0;
}

private boolean similar(String word1, String word2){

    if(word1.length() != word2.length() || word1.equals(word2))
        throw new IllegalArgumentException();

    int diff = 0;
    for(int i = 0 ; i < word1.length() ; i ++)
        if(word1.charAt(i) != word2.charAt(i)){
            diff ++;
            if(diff > 1)
                return false;
        }
    return true;
}
```

#### 方法三

```java
/// Bi-directional BFS
/// Time Complexity: O(n*n)
/// Space Complexity: O(n)
public class Solution3 {

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {

        int end = wordList.indexOf(endWord);
        if(end == -1)
            return 0;

        if(!wordList.contains(beginWord))
            wordList.add(beginWord);
        int begin = wordList.indexOf(beginWord);

        int n = wordList.size();
        boolean[][] g = new boolean[n][n];
        for(int i = 0 ; i < n ; i ++)
            for(int j = 0 ; j < i ; j ++)
                g[j][i] = g[i][j] = similar(wordList.get(i), wordList.get(j));


        // bi-derectional-bfs
        LinkedList<Integer> qStart = new LinkedList<>();
        LinkedList<Integer> qEnd = new LinkedList<>();

        int[] stepStart = new int[n];
        int[] stepEnd = new int[n];

        qStart.addLast(begin);
        stepStart[begin] = 1;

        qEnd.addLast(end);
        stepEnd[end] = 1;

        while(!qStart.isEmpty() && !qEnd.isEmpty()){

            int curStart = qStart.removeFirst();
            int curEnd = qEnd.removeFirst();

            for(int i = 0 ; i < n ; i ++) {
                if (stepStart[i] == 0 && g[curStart][i]) {
                    stepStart[i] = stepStart[curStart] + 1;
                    qStart.addLast(i);
                }
            }

            for(int i = 0 ; i < n ; i ++){
                if(stepEnd[i] == 0 && g[curEnd][i]){
                    stepEnd[i] = stepEnd[curEnd] + 1;
                    qEnd.addLast(i);
                }
            }

            // check intersection
            int res = Integer.MAX_VALUE;
            for(int i = 0 ; i < n ; i ++)
                if(stepStart[i] != 0 && stepEnd[i] != 0)
                    res = Integer.min(res, stepStart[i] + stepEnd[i] - 1);

            if(res != Integer.MAX_VALUE)
                return res;
        }

        return 0;
    }

    private boolean similar(String word1, String word2){

        if(word1.length() != word2.length() || word1.equals(word2))
            throw new IllegalArgumentException();

        int diff = 0;
        for(int i = 0 ; i < word1.length() ; i ++)
            if(word1.charAt(i) != word2.charAt(i)){
                diff ++;
                if(diff > 1)
                    return false;
            }
        return true;
    }
}
```

#### 方法四

```java
/// Bi-directional BFS
/// No need to calculate all pairs similarity
/// Time Complexity: O(n*n)
/// Space Complexity: O(n)
public class Solution4 {
    
	public int ladderLength(String beginWord, String endWord, List<String> wordList) {

        if(!wordList.contains(endWord))
            return 0;

        // bi-derectional-bfs
        LinkedList<String> qStart = new LinkedList<>();
        LinkedList<String> qEnd = new LinkedList<>();

        HashMap<String, Integer> stepStart = new HashMap<>();
        HashMap<String, Integer> stepEnd = new HashMap<>();

        qStart.addLast(beginWord);
        stepStart.put(beginWord, 1);

        qEnd.addLast(endWord);
        stepEnd.put(endWord, 1);

        while(!qStart.isEmpty() && !qEnd.isEmpty()){

            String curStartWord = qStart.removeFirst();
            String curEndWord = qEnd.removeFirst();
            for(String word: wordList){
                if(!stepStart.containsKey(word) && similar(word, curStartWord)){
                    stepStart.put(word, stepStart.get(curStartWord) + 1);
                    qStart.addLast(word);
                }

                if(!stepEnd.containsKey(word) && similar(word, curEndWord)){
                    stepEnd.put(word, stepEnd.get(curEndWord) + 1);
                    qEnd.addLast(word);
                }
            }

            // check intersection
            int res = Integer.MAX_VALUE;
            for(String word: wordList)
                if(stepStart.containsKey(word) && stepEnd.containsKey(word))
                    res = Integer.min(res,
                            stepStart.get(word) + stepEnd.get(word) - 1);

            if(res != Integer.MAX_VALUE)
                return res;
        }

        return 0;
    }

    private boolean similar(String word1, String word2){

        if(word1.length() != word2.length() || word1.equals(word2))
            throw new IllegalArgumentException();

        int diff = 0;
        for(int i = 0 ; i < word1.length() ; i ++)
            if(word1.charAt(i) != word2.charAt(i)){
                diff ++;
                if(diff > 1)
                    return false;
            }
        return true;
    }
}
```

## 二叉树和递归

### Maximum Depth of Binary Tree(LeetCode)

```java
// 104. Maximum Depth of Binary Tree
// https://leetcode.com/problems/maximum-depth-of-binary-tree
// 时间复杂度: O(n), n是树中的节点个数
// 空间复杂度: O(h), h是树的高度
public int maxDepth(TreeNode root) {

    if(root == null)
        return 0;

    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

### Invert Binary Tree（LeetCode）

```java
/// 226. Invert Binary Tree
/// https://leetcode.com/problems/invert-binary-tree
/// 时间复杂度: O(n), n为树中节点个数
/// 空间复杂度: O(h), h为树的高度
public TreeNode invertTree(TreeNode root) {

    if(root == null)
        return null;

    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    root.left = right;
    root.right = left;

    return root;
}
```

### Path Sum（LeetCode）

```java
/// 112. Path Sum
/// https://leetcode.com/problems/path-sum
/// 时间复杂度: O(n), n为树的节点个数
/// 空间复杂度: O(h), h为树的高度
public boolean hasPathSum(TreeNode root, int sum) {

    if(root == null)
        return false;

    if(root.left == null && root.right == null)
        return sum == root.val;

    return hasPathSum(root.left, sum - root.val)
            || hasPathSum(root.right, sum - root.val);
}
```

### Binary Tree Paths（LeetCode）

```java
/// 257. Binary Tree Paths
/// https://leetcode.com/problems/binary-tree-paths
/// 时间复杂度: O(n), n为树中的节点个数
/// 空间复杂度: O(h), h为树的高度
public List<String> binaryTreePaths(TreeNode root) {

    ArrayList<String> res = new ArrayList<String>();

    if(root == null)
        return res;

    if(root.left == null && root.right == null){
        res.add(Integer.toString(root.val));
        return res;
    }

    List<String> leftPaths = binaryTreePaths(root.left);
    for(String s: leftPaths){
        StringBuilder sb = new StringBuilder(Integer.toString(root.val));
        sb.append("->");
        sb.append(s);
        res.add(sb.toString());
    }

    List<String> rightPaths = binaryTreePaths(root.right);
    for(String s: rightPaths) {
        StringBuilder sb = new StringBuilder(Integer.toString(root.val));
        sb.append("->");
        sb.append(s);
        res.add(sb.toString());
    }

    return res;
}
```

### Path Sum III（LeetCode）

```java
/// 437. Path Sum III
/// https://leetcode.com/problems/path-sum-iii/description/
/// 时间复杂度: O(n), n为树的节点个数
/// 空间复杂度: O(h), h为树的高度
// 在以root为根节点的二叉树中,寻找和为sum的路径,返回这样的路径个数
public int pathSum(TreeNode root, int sum) {

    if(root == null)
        return 0;

    return findPath(root, sum)
            + pathSum(root.left , sum)
            + pathSum(root.right , sum);
}

// 在以node为根节点的二叉树中,寻找包含node的路径,和为sum
// 返回这样的路径个数
private int findPath(TreeNode node, int num){

    if(node == null)
        return 0;

    int res = 0;
    if(node.val == num)
        res += 1;

    res += findPath(node.left , num - node.val);
    res += findPath(node.right , num - node.val);

    return res;
}
```

### Lowest Common Ancestor of a Binary Search Tree（LeetCode）

```java
/// 235. Lowest Common Ancestor of a Binary Search Tree
/// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree
/// 时间复杂度: O(lgn), 其中n为树的节点个数
/// 空间复杂度: O(h), 其中h为树的高度
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

    if(p == null || q == null)
        throw new IllegalArgumentException("p or q can not be null.");

    if(root == null)
        return null;

    if(p.val < root.val && q.val < root.val)
        return lowestCommonAncestor(root.left, p, q);
    if(p.val > root.val && q.val > root.val)
        return lowestCommonAncestor(root.right, p, q);

    assert p.val == root.val || q.val == root.val
            || (root.val - p.val) * (root.val - q.val) < 0;

    return root;
}
```
