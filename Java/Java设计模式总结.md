# 设计原则

## 开闭原则

对扩展开放，对修改关闭

## 迪米特法则

俗称：最小知道原则

## 里氏替换原则

通俗的讲：子类可以扩展父类的功能，但不可以改变父类原有的功能。

## 依赖倒置原则



## 合成复用原则

组合优于继承

------

# 设计模式

## 创建型（5）

**主要用于创建对象**

### 1  单例模式

#### 定义

保证内存中有且只有一个实例对象

#### 优缺点

##### 优点

- 防止频繁创建对象，使得内存飙升

##### 缺点

#### 使用场景

#### 代码示例

- 恶汉模式
- 懒汉模式
- Double Check模式
- 内部静态类
- 枚举类

### 2  简单工厂模式

不属于23种经典设计模式，编程习惯。

#### 定义

由一个工厂对象决定创建出哪一个产品类的实例

#### 角色

- 抽象产品：定了产品的规范，描述了产品的特性和功能
- 具体产品：实现或继承了抽象产品类
- 具体工厂：提供创建产品的方法

#### UML类图

#### 优缺点

##### 优点

- 降低模块间耦合。对象的创建和对象的使用分离
- 良好的封装性，代码结构清晰。创建对象时只需要传入对应的参数，并不关心具体的创建逻辑

##### 缺点

- 新增具体产品类时，需要修改具体工厂类，违反了开闭原则
- 具体的产品类过多时，工厂类创建工厂的方法过于复杂，不利于维护

#### 使用场景

- 工厂类创建的对象较少
- 客户只关心传入工厂类的参数，对于如何创建对象的具体逻辑并不关心

#### 代码示例

### 3  工厂方法模式

#### 定义

定义了一个创建某种产品的接口，把产品的实例化推迟到子类实现，由子类决定需要实例化的产品是哪一个。

#### 角色

- 抽象产品

- 具体产品

- 抽象工厂

- 具体工厂

#### UML类图

#### 优缺点

##### 优点

- 符合开闭原则

##### 缺点

- 增加了代码量，每一个具体的产品都需要一个具体的工厂

#### 使用场景

- 一般配合策略模式一起使用

#### 代码示例

### 4  抽象工厂模式

#### 定义

#### 角色

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

#### 代码示例

### 5  建造者模式

#### 定义

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

#### 角色

抽象的建造者：

具体的建造者：

普通的类：

指挥者：

#### UML类图

#### 优缺点

##### 优点

- 用户不需要知道建造的过程和细节皆可以创建出复杂的对象
- 用户只需给出复杂对象的内容和类型就可以创建出对象

##### 缺点

#### 使用场景

#### 代码示例

### 6  原型模式

#### 定义

#### 角色

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

#### 代码示例

## 结构型（7）

**关注于如何将现有类或对象组织在一起**

- 类结构型模式：关系类的组合，一般只存在继承和实现关系

- 对象结构型模式：关系类与对象的组合，一般只存在组合关系，符合“合成复用原则”

### 1  组合模式

#### 定义

将对象组合成树形结构以表示“部分-整体”的层次结构。

#### 角色

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

##### 设计阶段

#### 代码示例



### 2  装饰器模式

#### 定义

在不改变原有类的情况下，动态的给一个对象添加一些额外的职责

#### 角色

- 抽象构件（Component）
- 具体构件（ConcreteComponent）
- 抽象装饰者（Decorator）
- 具体装饰者（ConcreteDecorator）

#### UML类图

#### 优缺点

##### 优点

- 符合开闭原则：在不改变原有类的情况下，动态给对象扩展功能，即插即用
- 装饰类和被装饰类之间可以独立发展，不会相互耦合
- 将类的核心功能和装饰功能区分开，简化了原有类的复杂性

##### 缺点

- 子类过多，增加程序的复杂性

#### 使用场景

需要扩展已有类的功能，又不想增加原有类的复杂性

#### 代码示例

Java I/O系统的实现

### 3  代理模式

#### 定义

为其他对象提供一个代理对象，并由代理对象控制这个对象的访问。

#### 角色

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

##### 设计阶段

#### 代码示例

### 4  适配器模式

#### 定义

将一个接口转换为另一个客户期望的接口

#### 角色

- 目标抽象类（Target）
- 适配器类（Adapter）
- 被适配者类（Adaptee）

#### UML类图

#### 优缺点

##### 优点

- 将目标类和适配者类解耦，可以在不修改原有代码的基础上增加新的适配器，完全符合“开闭原则”

##### 缺点

#### 使用场景

希望复用原有代码实现新的功能时，考虑使用适配器模式

##### 设计阶段

代码维护阶段

#### 代码示例

### 5  外观模式

俗称：门面模式

#### 定义

#### 角色

- 外观角色（Facade）
- 子系统角色（SubSystem）

#### UML类图

#### 优缺点

##### 优点

- 让外部减少与子系统内多个模块的交互，松耦合

##### 缺点

#### 使用场景

##### 设计阶段

#### 代码示例

### 6  桥接模式

#### 定义

将抽象部分与它的实现部分分离，使他们可以独立的变化。

#### 角色

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

##### 设计阶段

代码设计初期

#### 代码示例



## 行为型（11）

**关注系统中类或对象之间的交互，进一步明确对象的职责**

### 1  策略模式

#### 定义

一个类的行为或算法可以在运行时更改

#### 角色

抽象策略：通常由一个接口或抽象类实现

具体策略：包装了相关的算法或行为，实现或继承了抽象策略角色

应用上下文：上下文角色，持有一个Strategy的引用

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

#### 扩展

- 可以使用map + 函数式接口优化
- 可以使用简单工厂 + 策略模式进行优化

使用策略模式优化if...else...逻辑，它的优化点在于抽象出了接口，将业务逻辑封装成了一个个实现类，任意替换；在复杂业务场景（业务逻辑较多）时比直接使用if...else...更好维护。

#### 代码示例

### 2  模板方法模式

#### 定义

定义了一个算法骨架，将具体的步骤延迟到子类实现

#### 角色

- 抽象父类

- 具体类

#### UML类图

#### 优缺点

##### 优点

- 良好的封装性和扩展性：父类封装了不可变部分，而子类扩展了可变部分
- 代码复用：将公共代码提取到父类中实现
- 符合开闭原则和单一职责原则：增加功能由子类扩展

##### 缺点

- 子类过多，增加的系统复杂度
- 父类添加新的抽象方法，所有子类需要实现一遍
- 子类的执行影响父类的执行结果，增加代码阅读难度

#### 使用场景

区分代码的可变部分和不可变部分

#### 扩展

方法包括：模板方法、抽象方法、具体方法、钩子方法。正确的使用钩子方法，可以使得子类控制父类的行为。

#### 代码示例

ArrayList的源码

