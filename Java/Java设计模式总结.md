# 设计原则

## 开闭原则

对扩展开放，对修改关闭

## 迪米特法则

## 合成复用原则



------

# 设计模式

## 创建型（5）

**主要用于创建对象**

### 单例模式

#### 定义

保证内存中有且只有一个实例对象

#### 优缺点

##### 优点

- 防止频繁创建对象，使得内存飙升

##### 缺点

#### 使用场景

#### 代码示例

- 恶汉模式
- 懒汉模式
- Double Check模式
- 内部静态类
- 枚举类

### 简单工厂模式

#### 定义

#### 角色

#### UML类图

#### 优缺点

##### 优点

##### 缺点

#### 使用场景

#### 代码示例

## 结构型（7）

**关注于如何将现有类或对象组织再一起**

- 类结构型模式：关系类的组合，一般只存在继承和实现关系

- 对象结构型模式：关系类与对象的组合，一般只存在组合关系，更符合合成复用原则

### 装饰器模式

#### 定义

在不改变原有类的情况下，动态的给一个对象添加一些额外的职责

#### 角色

- 抽象构件（Component）
- 具体构件（ConcreteComponent）
- 抽象装饰者（Decorator）
- 具体装饰者（ConcreteDecorator）

#### UML类图

#### 优缺点

##### 优点

- 符合开闭原则：在不改变原有类的情况下，动态给对象扩展功能，即插即用
- 装饰类和被装饰类之间可以独立发展，不会相互耦合
- 将类的核心功能和装饰功能区分开，简化了原有类的复杂性

##### 缺点

- 子类过多，增加程序的复杂性

#### 使用场景

需要扩展已有类的功能，又不想增加原有类的复杂性

#### 代码示例

Java I/O系统的实现

## 行为型（11）

**关注系统中类或对象之间的交互，进一步明确对象的职责**

### 策略模式



### 模板方法模式

#### 定义

定义了一个算法骨架，将具体的步骤延迟到子类实现

#### 角色

- 抽象父类

- 具体类

#### UML类图

#### 优缺点

##### 优点

- 良好的封装性和扩展性：父类封装了不可变部分，而子类扩展了可变部分
- 代码复用：将公共代码提取到父类中实现
- 符合开闭原则和单一职责原则：增加功能由子类扩展

##### 缺点

- 子类过多，增加的系统复杂度
- 父类添加新的抽象方法，所有子类需要实现一遍
- 子类的执行影响父类的执行结果，增加代码阅读难度

#### 使用场景

区分代码的可变部分和不可变部分

#### 扩展

方法包括：模板方法、抽象方法、具体方法、钩子方法。正确的使用钩子方法，可以使得子类控制父类的行为。

#### 代码示例

ArrayList的源码
